use crate::core::{
    errors::{ExchangeError, ResultExt},
    traits::OrderPlacer,
    types::{OrderRequest, OrderResponse},
};
use crate::exchanges::backpack::{
    client::BackpackConnector,
    types::{BackpackApiResponse, BackpackOrderRequest, BackpackOrderResponse},
};
use async_trait::async_trait;
use serde_json;

// Helper function to create headers safely
fn create_headers_safe(
    headers: std::collections::HashMap<String, String>,
) -> Result<reqwest::header::HeaderMap, ExchangeError> {
    let mut header_map = reqwest::header::HeaderMap::new();

    for (k, v) in headers {
        let header_name = reqwest::header::HeaderName::from_bytes(k.as_bytes())
            .map_err(|e| ExchangeError::Other(format!("Invalid header name '{}': {}", k, e)))?;
        let header_value = reqwest::header::HeaderValue::from_str(&v)
            .map_err(|e| ExchangeError::Other(format!("Invalid header value '{}': {}", v, e)))?;
        header_map.insert(header_name, header_value);
    }

    Ok(header_map)
}

#[async_trait]
impl OrderPlacer for BackpackConnector {
    #[allow(clippy::too_many_lines)]
    async fn place_order(&self, order: OrderRequest) -> Result<OrderResponse, ExchangeError> {
        let backpack_order = BackpackOrderRequest {
            symbol: order.symbol.clone(),
            side: match order.side {
                crate::core::types::OrderSide::Buy => "BUY".to_string(),
                crate::core::types::OrderSide::Sell => "SELL".to_string(),
            },
            order_type: match order.order_type {
                crate::core::types::OrderType::Market => "MARKET".to_string(),
                crate::core::types::OrderType::Limit => "LIMIT".to_string(),
                crate::core::types::OrderType::StopLoss => "STOP_MARKET".to_string(),
                crate::core::types::OrderType::StopLossLimit => "STOP_LIMIT".to_string(),
                crate::core::types::OrderType::TakeProfit => "TAKE_PROFIT_MARKET".to_string(),
                crate::core::types::OrderType::TakeProfitLimit => "TAKE_PROFIT_LIMIT".to_string(),
            },
            quantity: order.quantity,
            price: order.price,
            time_in_force: order.time_in_force.map(|tif| match tif {
                crate::core::types::TimeInForce::GTC => "GTC".to_string(),
                crate::core::types::TimeInForce::IOC => "IOC".to_string(),
                crate::core::types::TimeInForce::FOK => "FOK".to_string(),
            }),
            client_order_id: None, // Will be generated by the exchange
            stop_price: order.stop_price,
            working_type: None,
            price_protect: None,
            close_position: None,
            activation_price: None,
            callback_rate: None,
        };

        // Create signed headers for the order request
        let instruction = "order";
        let params = serde_json::to_string(&backpack_order).with_exchange_context(|| {
            format!("Failed to serialize order for symbol {}", order.symbol)
        })?;

        let headers = self
            .create_signed_headers(instruction, &params)
            .with_exchange_context(|| {
                format!(
                    "Failed to create signed headers for order: symbol={}",
                    order.symbol
                )
            })?;

        let url = format!("{}/api/v1/order", self.base_url);

        let response = self
            .client
            .post(&url)
            .headers(create_headers_safe(headers)?)
            .json(&backpack_order)
            .send()
            .await
            .with_exchange_context(|| {
                format!(
                    "Failed to send order request: url={}, symbol={}",
                    url, order.symbol
                )
            })?;

        if !response.status().is_success() {
            return Err(ExchangeError::ApiError {
                code: response.status().as_u16() as i32,
                message: format!("Failed to place order: {}", response.status()),
            });
        }

        let api_response: BackpackApiResponse<BackpackOrderResponse> =
            response.json().await.with_exchange_context(|| {
                format!("Failed to parse order response for symbol {}", order.symbol)
            })?;

        if !api_response.success {
            return Err(ExchangeError::ApiError {
                code: api_response.error.as_ref().map_or(-1, |e| e.code),
                message: api_response
                    .error
                    .map_or_else(|| "Unknown error".to_string(), |e| e.msg),
            });
        }

        let backpack_response = api_response.data.ok_or_else(|| ExchangeError::ApiError {
            code: -1,
            message: "No order response received".to_string(),
        })?;

        Ok(OrderResponse {
            order_id: backpack_response.order_id.to_string(),
            client_order_id: backpack_response.client_order_id.unwrap_or_default(),
            symbol: backpack_response.symbol,
            side: match backpack_response.side.as_str() {
                "BUY" => crate::core::types::OrderSide::Buy,
                "SELL" => crate::core::types::OrderSide::Sell,
                _ => {
                    return Err(ExchangeError::Other(
                        "Invalid order side in response".to_string(),
                    ))
                }
            },
            order_type: match backpack_response.order_type.as_str() {
                "MARKET" => crate::core::types::OrderType::Market,
                "LIMIT" => crate::core::types::OrderType::Limit,
                "STOP_MARKET" => crate::core::types::OrderType::StopLoss,
                "STOP_LIMIT" => crate::core::types::OrderType::StopLossLimit,
                "TAKE_PROFIT_MARKET" => crate::core::types::OrderType::TakeProfit,
                "TAKE_PROFIT_LIMIT" => crate::core::types::OrderType::TakeProfitLimit,
                _ => {
                    return Err(ExchangeError::Other(
                        "Invalid order type in response".to_string(),
                    ))
                }
            },
            quantity: backpack_response.quantity,
            price: backpack_response.price,
            status: backpack_response.status,
            timestamp: backpack_response.timestamp,
        })
    }

    async fn cancel_order(&self, symbol: String, order_id: String) -> Result<(), ExchangeError> {
        let cancel_request = crate::exchanges::backpack::types::BackpackCancelOrderRequest {
            symbol: symbol.clone(),
            order_id: Some(order_id.parse().map_err(|_| {
                ExchangeError::InvalidParameters("Invalid order ID format".to_string())
            })?),
            client_order_id: None,
        };

        // Create signed headers for the cancel request
        let instruction = "cancelOrder";
        let params = serde_json::to_string(&cancel_request).with_exchange_context(|| {
            format!(
                "Failed to serialize cancel request: symbol={}, order_id={}",
                symbol, order_id
            )
        })?;

        let headers = self
            .create_signed_headers(instruction, &params)
            .with_exchange_context(|| {
                format!(
                    "Failed to create signed headers for cancel: symbol={}, order_id={}",
                    symbol, order_id
                )
            })?;

        let url = format!("{}/api/v1/order", self.base_url);

        let response = self
            .client
            .delete(&url)
            .headers(create_headers_safe(headers)?)
            .json(&cancel_request)
            .send()
            .await
            .with_exchange_context(|| {
                format!(
                    "Failed to send cancel request: url={}, symbol={}, order_id={}",
                    url, symbol, order_id
                )
            })?;

        if !response.status().is_success() {
            return Err(ExchangeError::ApiError {
                code: response.status().as_u16() as i32,
                message: format!("Failed to cancel order: {}", response.status()),
            });
        }

        let api_response: BackpackApiResponse<()> =
            response.json().await.with_exchange_context(|| {
                format!(
                    "Failed to parse cancel response: symbol={}, order_id={}",
                    symbol, order_id
                )
            })?;

        if !api_response.success {
            return Err(ExchangeError::ApiError {
                code: api_response.error.as_ref().map_or(-1, |e| e.code),
                message: api_response
                    .error
                    .map_or_else(|| "Unknown error".to_string(), |e| e.msg),
            });
        }

        Ok(())
    }
}

impl BackpackConnector {
    /// Get all open orders for a symbol
    pub async fn get_open_orders(
        &self,
        symbol: Option<String>,
    ) -> Result<Vec<crate::exchanges::backpack::types::BackpackOrder>, ExchangeError> {
        let mut params = Vec::new();

        if let Some(symbol) = symbol {
            params.push(("symbol".to_string(), symbol));
        }

        let query_string = if params.is_empty() {
            String::new()
        } else {
            format!("?{}", Self::create_query_string(&params))
        };

        let url = format!("{}/api/v1/openOrders{}", self.base_url, query_string);

        // Create signed headers for the request
        let instruction = "openOrders";
        let params_str = if params.is_empty() {
            String::new()
        } else {
            Self::create_query_string(&params)
        };

        let headers = self
            .create_signed_headers(instruction, &params_str)
            .with_exchange_context(|| {
                format!(
                    "Failed to create signed headers for open orders: params={:?}",
                    params
                )
            })?;

        let response = self
            .client
            .get(&url)
            .headers(create_headers_safe(headers)?)
            .send()
            .await
            .with_exchange_context(|| format!("Failed to send open orders request: url={}", url))?;

        if !response.status().is_success() {
            return Err(ExchangeError::ApiError {
                code: response.status().as_u16() as i32,
                message: format!("Failed to get open orders: {}", response.status()),
            });
        }

        let api_response: BackpackApiResponse<
            Vec<crate::exchanges::backpack::types::BackpackOrder>,
        > = response
            .json()
            .await
            .with_exchange_context(|| "Failed to parse open orders response".to_string())?;

        if !api_response.success {
            return Err(ExchangeError::ApiError {
                code: api_response.error.as_ref().map_or(-1, |e| e.code),
                message: api_response
                    .error
                    .map_or_else(|| "Unknown error".to_string(), |e| e.msg),
            });
        }

        api_response.data.ok_or_else(|| ExchangeError::ApiError {
            code: -1,
            message: "No open orders data received".to_string(),
        })
    }

    /// Get order status by order ID
    #[allow(clippy::too_many_lines)]
    pub async fn get_order(
        &self,
        symbol: String,
        order_id: Option<i64>,
        client_order_id: Option<String>,
    ) -> Result<crate::exchanges::backpack::types::BackpackOrder, ExchangeError> {
        let mut params = vec![("symbol".to_string(), symbol.clone())];

        if let Some(order_id) = order_id {
            params.push(("orderId".to_string(), order_id.to_string()));
        }

        if let Some(client_order_id) = client_order_id {
            params.push(("origClientOrderId".to_string(), client_order_id));
        }

        let query_string = format!("?{}", Self::create_query_string(&params));
        let url = format!("{}/api/v1/order{}", self.base_url, query_string);

        // Create signed headers for the request
        let instruction = "order";
        let params_str = Self::create_query_string(&params);

        let headers = self
            .create_signed_headers(instruction, &params_str)
            .with_exchange_context(|| {
                format!(
                    "Failed to create signed headers for get order: symbol={}",
                    symbol
                )
            })?;

        let response = self
            .client
            .get(&url)
            .headers(create_headers_safe(headers)?)
            .send()
            .await
            .with_exchange_context(|| {
                format!(
                    "Failed to send get order request: url={}, symbol={}",
                    url, symbol
                )
            })?;

        if !response.status().is_success() {
            return Err(ExchangeError::ApiError {
                code: response.status().as_u16() as i32,
                message: format!("Failed to get order: {}", response.status()),
            });
        }

        let api_response: BackpackApiResponse<crate::exchanges::backpack::types::BackpackOrder> =
            response.json().await.with_exchange_context(|| {
                format!("Failed to parse order response for symbol {}", symbol)
            })?;

        if !api_response.success {
            return Err(ExchangeError::ApiError {
                code: api_response.error.as_ref().map_or(-1, |e| e.code),
                message: api_response
                    .error
                    .map_or_else(|| "Unknown error".to_string(), |e| e.msg),
            });
        }

        api_response.data.ok_or_else(|| ExchangeError::ApiError {
            code: -1,
            message: "No order data received".to_string(),
        })
    }
}
